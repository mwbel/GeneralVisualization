<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../assets/style.css">

  <style>
    body { font-family: 'Noto Sans SC', system-ui, -apple-system, Segoe UI, PingFang SC, Helvetica, Arial, sans-serif; margin:0; }
    .wrap { max-width: 960px; margin: 20px auto; padding: 16px; }
    .card { background:#f9f9fb; border-radius: 16px; padding: 16px; box-shadow:0 12px 30px rgba(0,0,0,.12); }
  </style>
  
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js"></script></head><body>
  <header style="padding:16px;background:linear-gradient(135deg, #4A65F6, #6C8BFA);color:#fff;">
    <h1 style="margin:0;font-size:22px;">AI 生成的交互式可视化</h1>
    <p style="margin:4px 0 0;opacity:.9;">类型：几何结构｜复杂度：简单</p>
    <p style="margin:4px 0 0;opacity:.9;">需求：创建一个可旋转的3D球体，可调整参数和观察角度</p>
    <a href="../../../../index.html" style="color:#fff;text-decoration:underline;">返回首页</a>
  </header><div class="wrap"><div class="card"><div id="scene" style="width:100%;height:560px;"></div></div></div><script>(function(){
const el=document.getElementById('scene');
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(el.clientWidth, el.clientHeight); el.appendChild(renderer.domElement);
const scene=new THREE.Scene(); scene.background=new THREE.Color(0xf5f6fa);
const camera=new THREE.PerspectiveCamera(60, el.clientWidth/el.clientHeight, 0.1, 1000); camera.position.set(3,3,3);
const controls=new THREE.OrbitControls(camera, renderer.domElement);
const light=new THREE.DirectionalLight(0xffffff, 1); light.position.set(5,5,5); scene.add(light); scene.add(new THREE.AmbientLight(0x8899aa, .6));
const g=new THREE.BoxGeometry(1,1,1);
const m=new THREE.MeshStandardMaterial({color:0x4A65F6, metalness:.2, roughness:.6});
const cube=new THREE.Mesh(g,m); scene.add(cube);
function animate(){ requestAnimationFrame(animate); cube.rotation.x+=0.005; cube.rotation.y+=0.01; controls.update(); renderer.render(scene,camera);} animate();
window.addEventListener('resize',()=>{ renderer.setSize(el.clientWidth, el.clientHeight); camera.aspect=el.clientWidth/el.clientHeight; camera.updateProjectionMatrix(); });
})();</script></body></html>