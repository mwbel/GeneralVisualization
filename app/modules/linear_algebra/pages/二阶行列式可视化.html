<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二阶行列式可视化 - 一图胜千言</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="../frontend/global-mathjax.js"></script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            display: flex;
        }

        .sidebar {
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 2px 0 15px rgba(0,0,0,0.1);
            padding: 20px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
        }

        .sidebar-title {
            font-size: 1.4em;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 15px;
        }

        .nav-item {
            display: block;
            padding: 12px 15px;
            margin: 8px 0;
            color: #4a5568;
            text-decoration: none;
            border-radius: 10px;
            transition: all 0.3s;
            font-weight: 500;
            border-left: 4px solid transparent;
        }

        .nav-item:hover {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            transform: translateX(5px);
            border-left-color: #667eea;
        }

        .nav-item.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-left-color: #667eea;
        }

        .page-content {
            margin-left: 280px;
            flex: 1;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .theory-section, .visualization-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .section-title {
            font-size: 1.5em;
            color: #4a5568;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .definition-box {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .formula {
            font-size: 1.3em;
            text-align: center;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #4a5568;
        }

        .control-group input {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .control-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .result-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .result-display h3 {
            margin-bottom: 10px;
        }

        .result-display .formula {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            backdrop-filter: blur(10px);
        }

        .result-display .formula * {
            color: white !important;
        }

        /* 确保MathJax在深色背景下正确显示 */
        .result-display mjx-container,
        .result-display mjx-container *,
        .result-display .MathJax,
        .result-display .MathJax * {
            color: white !important;
            background: transparent !important;
        }

        .result-display mjx-math {
            color: white !important;
        }

        .calculation-steps {
            color: #111; 
            font-size: 1.1em;
            margin: 10px 0;
            font-weight: 500;
        }

        .result-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
            color: #ffffff !important;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: transparent !important;
        }

        #determinant-result {
            color: #ffffff !important;
            background: transparent !important;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .geometric-meaning {
            background: #e6fffa;
            border: 2px solid #38b2ac;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .geometric-meaning h4 {
            color: #2c7a7b;
            margin-bottom: 10px;
        }

        .plot-container {
            height: 500px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            margin: 20px 0;
        }

        .examples-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-top: 30px;
        }

        .example-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .example-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .example-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
        /* 1) 让“计算步骤”本身与其父容器不再半透明 */
        #calc-steps, .calc-steps, .result-steps,    
        #calc-steps *, .calc-steps *, .result-steps * {
            color: #111 !important;
            opacity: 1 !important;      /* 关键：取消任何淡化 */
            filter: none !important;
        }

        /* 2) 如果整张结果卡片被整体降了透明度，也把它拉回不透明 */
        .result-card, #resultCard, .result-panel {
        opacity: 1 !important;
        }
        /* 3) 允许卡片在一行时收缩，否则会被内容撑破 */
        .example-grid .example-card {
            min-width: 0;        /* 必需：防止被内容撑破 */
            overflow: visible;   /* ← 原来如果写了 hidden，这里改成 visible 或直接删掉 */
        }

        /* 4) 让“公式所在容器”和 MathJax 容器不越界，必要时横向滚动 */
        .example-card .formula {
            max-width: 100%;
            overflow-x: auto;       /* 超宽时出现横向滚动条 */
            -webkit-overflow-scrolling: touch;
             padding-bottom: 4px;           /* 给滚动条留点空间（可选） */
             scrollbar-gutter: stable both-edges; /* 可选：滚动条常驻不抖动 */
        }

        .example-card .formula mjx-container{
          display: inline-block !important;
          min-width: max-content;        /* 关键：内容多宽就多宽 */
          max-width: 100%;               /* 但外层仍会限制并触发滚动 */
          overflow: visible;             /* 由外层控制滚动，不在这里裁剪 */
          text-align: left;              /* 可选：左对齐 */
        }  
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-title">线性代数模块</div>
        <a href="linear-algebra-module.html" class="nav-item">模块概览</a>
        <a href="二阶行列式可视化.html" class="nav-item active">二阶行列式</a>
        <a href="三阶行列式可视化.html" class="nav-item">三阶行列式</a>
        <a href="矩阵运算可视化.html" class="nav-item">矩阵运算</a>
        <a href="向量空间可视化.html" class="nav-item">向量空间</a>
        <a href="../index.html">返回 “线性代数可视化世界”首页</a>
<a href="../../../index.html" class="nav-item">返回 “万物可视化”首页</a>
    </div>
    
    <div class="page-content">
    <div class="container">
        <div class="header">
            <h1>二阶行列式可视化</h1>
            <p>探索二阶行列式的数学定义与几何意义</p>
        </div>

        <div class="main-content">
            <div class="theory-section">
                <h2 class="section-title">代数定义</h2>
                
                <div class="definition-box">
                    <h3>定义</h3>
                    <p>以数 \(a_{11}, a_{12}, a_{21}, a_{22}\) 为元素的二阶行列式为：</p>
                    <div class="formula">
                        $$\begin{vmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{vmatrix} = a_{11}a_{22} - a_{12}a_{21}$$
                    </div>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label for="a11">a₁₁ =</label>
                        <input type="number" id="a11" value="3" step="0.1">
                    </div>
                    <div class="control-group">
                        <label for="a12">a₁₂ =</label>
                        <input type="number" id="a12" value="1" step="0.1">
                    </div>
                    <div class="control-group">
                        <label for="a21">a₂₁ =</label>
                        <input type="number" id="a21" value="2" step="0.1">
                    </div>
                    <div class="control-group">
                        <label for="a22">a₂₂ =</label>
                        <input type="number" id="a22" value="4" step="0.1">
                    </div>
                </div>

                <div class="result-display">
                    <h3>计算结果</h3>
                    <div class="result-value" id="determinant-result">10</div>
                    <div>平行四边形面积: <span id="area-display">10</span></div>
                </div>

                <div class="calculation-steps">
                  <h4>计算步骤（对角线法）</h4>

                  <div class="step">主对角线项：<span id="step1-math"></span></div>
                  <div class="step">副对角线项：<span id="step2-math"></span></div>
                  <div class="step">最终结果：<span id="step3-math"></span></div>
                </div>
            </div>

            <div class="visualization-section">
                <h2 class="section-title">几何意义</h2>
                
                <div class="geometric-meaning">
                    <h4>几何解释</h4>
                    <p>二阶行列式的值等于由两个列向量 <strong>$v_1 = (a_{11}, a_{21})$</strong> 和 <strong>$v_2 = (a_{12}, a_{22})$</strong> 张成的平行四边形的<strong>有向面积</strong>。</p>
                    <ul style="margin-top: 10px; padding-left: 20px;">
                        <li>当行列式值为正时，向量按逆时针方向排列</li>
                        <li>当行列式值为负时，向量按顺时针方向排列</li>
                        <li>当行列式值为零时，两向量共线</li>
                    </ul>
                </div>
                
                <div id="plot" class="plot-container"></div>
                
                <div style="margin-top: 20px;">
                    <h4>向量信息</h4>
                    <p><strong>向量 v₁:</strong> (<span id="v1-display">3, 2</span>)</p>
                    <p><strong>向量 v₂:</strong> (<span id="v2-display">1, 4</span>)</p>
                    <p><strong>平行四边形面积:</strong> <span id="area-display">10</span></p>
                </div>
            </div>
        </div>

        <div class="examples-section">
            <h2 class="section-title">典型例题与应用</h2>
            <div class="example-grid">
                <div class="example-card">
                    <h4>• 例 1：基本计算</h4>
                    <div class="formula">
                        $$\begin{vmatrix} 2 & -1 \\ 6 & 5 \end{vmatrix} = 2 \times 5 - (-1) \times 6 = 16$$
                    </div>
                    <p>这表示由向量 (2, 6) 和 (-1, 5) 张成的平行四边形面积为 16。</p>
                </div>
                
                <div class="example-card">
                    <h4>• 例 2：线性方程组</h4>
                    <p>对于方程组：</p>
                    <div class="formula">
                        $$\begin{cases} 3x_1 - 4x_2 = 5 \\ kx_1 + 2x_2 = -3 \end{cases}$$
                    </div>
                    <p>当系数行列式 \(\begin{vmatrix} 3 & -4 \\ k & 2 \end{vmatrix} = 6 + 4k \neq 0\) 时，即 \(k \neq -\frac{3}{2}\) 时，方程组有唯一解。</p>
                </div>
                
                <div class="example-card">
                    <h4>• 例 3：几何应用</h4>
                    <p>三角形的面积可以用行列式计算：</p>
                    <div class="formula">
                        $$S = \frac{1}{2}\left|\begin{vmatrix} x_1 & y_1 \\ x_2 & y_2 \end{vmatrix}\right|$$
                    </div>
                    <p>其中 $(x_1, y_1)$ 和 $(x_2, y_2)$ 是从原点出发的两个向量。</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Wait for both MathJax and Plotly to load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded');
            
            // Ensure correct navigation state
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                item.classList.remove('active');
            });
            
            // Add active class to current page nav item
            const currentPageNav = document.querySelector('a[href="二阶行列式可视化.html"]');
            if (currentPageNav) {
                currentPageNav.classList.add('active');
            }
            
            initializeVisualization();
        });

        function initializeVisualization() {
            // Check if Plotly is loaded
            if (typeof Plotly === 'undefined') {
                console.error('Plotly is not loaded, retrying...');
                // Try to load Plotly from alternative CDN
                if (!document.querySelector('script[src*="plotly"]')) {
                    const script = document.createElement('script');
                    script.src = 'https://cdn.plot.ly/plotly-2.26.0.min.js';
                    script.onload = function() {
                        console.log('Plotly loaded from alternative CDN');
                        setTimeout(initializeVisualization, 100);
                    };
                    script.onerror = function() {
                        console.error('Failed to load Plotly from alternative CDN');
                        document.getElementById('plot').innerHTML = '<div style="text-align: center; padding: 50px; color: #666;">可视化图表加载失败，请检查网络连接</div>';
                    };
                    document.head.appendChild(script);
                } else {
                    setTimeout(initializeVisualization, 100);
                }
                return;
            }
            
            console.log('Plotly loaded, initializing visualization');
            setupEventListeners();
            updateVisualization();
        }

        function setupEventListeners() {
             // Get input elements
             const inputs = {
                 a11: document.getElementById('a11'),
                 a12: document.getElementById('a12'),
                 a21: document.getElementById('a21'),
                 a22: document.getElementById('a22')
             };

             // Add event listeners
             Object.values(inputs).forEach(input => {
                 input.addEventListener('input', updateVisualization);
             });
         }

        function updateVisualization() {
            const a11 = parseFloat(document.getElementById('a11').value) || 0;
            const a12 = parseFloat(document.getElementById('a12').value) || 0;
            const a21 = parseFloat(document.getElementById('a21').value) || 0;
            const a22 = parseFloat(document.getElementById('a22').value) || 0;

            // Calculate determinant
            const det = a11 * a22 - a12 * a21;

            // Update display values
            document.getElementById('determinant-result').textContent = det.toFixed(2);
            document.getElementById('v1-display').textContent = `${a11}, ${a21}`;
            document.getElementById('v2-display').textContent = `${a12}, ${a22}`;
            document.getElementById('area-display').textContent = Math.abs(det).toFixed(2);
            
            // Update calculation steps
            const mainDiagonal = a11 * a22;
            const antiDiagonal = a12 * a21;

            // 生成 LaTeX（注意 JS 字符串里 \ 要转义成 \\）
            const s1 = `\\( a_{11} \\times a_{22} = ${a11} \\times ${a22} = ${mainDiagonal.toFixed(2)} \\)`;
            const s2 = `\\( a_{12} \\times a_{21} = ${a12} \\times ${a21} = ${antiDiagonal.toFixed(2)} \\)`;
            const s3 = `\\( ${mainDiagonal.toFixed(2)} - ${antiDiagonal.toFixed(2)} = ${det.toFixed(2)} \\)`;

// 写入到三个占位 span
document.getElementById('step1-math').innerHTML = s1;
document.getElementById('step2-math').innerHTML = s2;
document.getElementById('step3-math').innerHTML = s3;

// 只 typeset 计算步骤这一块，提升性能
if (window.MathJax && window.MathJax.typesetPromise) {
  MathJax.typesetPromise([document.querySelector('.calculation-steps')])
    .catch(err => console.log('MathJax typeset error:', err.message));
}

            
           
            // Update plot
            updatePlot(a11, a12, a21, a22, det);
            
            // Re-render MathJax if available
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise().catch(function (err) {
                    console.log('MathJax typeset error: ' + err.message);
                });
            }
        }

        function updatePlot(a11, a12, a21, a22, det) {
            // Vector coordinates
            const v1 = [a11, a21];
            const v2 = [a12, a22];
            
            // Parallelogram vertices
            const origin = [0, 0];
            const p1 = v1;
            const p2 = v2;
            const p3 = [v1[0] + v2[0], v1[1] + v2[1]];

            // Create traces
            const traces = [
                // Vector v1
                {
                    x: [0, v1[0]],
                    y: [0, v1[1]],
                    mode: 'lines+markers',
                    line: { color: '#e53e3e', width: 4 },
                    marker: { size: 8 },
                    name: 'v₁',
                    showlegend: true
                },
                // Vector v2
                {
                    x: [0, v2[0]],
                    y: [0, v2[1]],
                    mode: 'lines+markers',
                    line: { color: '#3182ce', width: 4 },
                    marker: { size: 8 },
                    name: 'v₂',
                    showlegend: true
                },
                // Parallelogram
                {
                    x: [origin[0], p1[0], p3[0], p2[0], origin[0]],
                    y: [origin[1], p1[1], p3[1], p2[1], origin[1]],
                    fill: 'toself',
                    fillcolor: det >= 0 ? 'rgba(72, 187, 120, 0.3)' : 'rgba(245, 101, 101, 0.3)',
                    line: { color: det >= 0 ? '#48bb78' : '#f56565', width: 2 },
                    mode: 'lines',
                    name: '平行四边形',
                    showlegend: true
                },
                // Grid lines for reference
                {
                    x: [-6, 6],
                    y: [0, 0],
                    mode: 'lines',
                    line: { color: '#e2e8f0', width: 1 },
                    showlegend: false,
                    hoverinfo: 'skip'
                },
                {
                    x: [0, 0],
                    y: [-6, 6],
                    mode: 'lines',
                    line: { color: '#e2e8f0', width: 1 },
                    showlegend: false,
                    hoverinfo: 'skip'
                }
            ];

            // Add vector labels
            const annotations = [
                {
                    x: v1[0] / 2,
                    y: v1[1] / 2,
                    text: 'v₁',
                    showarrow: false,
                    font: { size: 14, color: '#e53e3e' }
                },
                {
                    x: v2[0] / 2,
                    y: v2[1] / 2,
                    text: 'v₂',
                    showarrow: false,
                    font: { size: 14, color: '#3182ce' }
                },
                {
                    x: (p1[0] + p2[0]) / 2,
                    y: (p1[1] + p2[1]) / 2,
                    text: `面积 = ${Math.abs(det).toFixed(2)}`,
                    showarrow: false,
                    font: { size: 12, color: '#4a5568' },
                    bgcolor: 'rgba(255, 255, 255, 0.8)',
                    bordercolor: '#4a5568',
                    borderwidth: 1
                }
            ];

            const layout = {
                title: {
                    text: `二阶行列式的几何意义 (det = ${det.toFixed(2)})`,
                    font: { size: 16 }
                },
                xaxis: {
                    title: 'x',
                    range: [-6, 6],
                    zeroline: true,
                    zerolinecolor: '#4a5568',
                    zerolinewidth: 2,
                    gridcolor: '#e2e8f0'
                },
                yaxis: {
                    title: 'y',
                    range: [-6, 6],
                    zeroline: true,
                    zerolinecolor: '#4a5568',
                    zerolinewidth: 2,
                    gridcolor: '#e2e8f0'
                },
                annotations: annotations,
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(255, 255, 255, 0.8)',
                    bordercolor: '#4a5568',
                    borderwidth: 1
                },
                margin: { l: 50, r: 50, t: 50, b: 50 },
                plot_bgcolor: '#f8f9fa',
                paper_bgcolor: 'white'
            };

            const config = {
                responsive: true,
                displayModeBar: false
            };

            Plotly.newPlot('plot', traces, layout, config);
        }

        function goBack() {
            window.location.href = '../index.html';
        }
    </script>
    </div>
</body>
</html>